---
title: "ERGM_team"
author: "Timo Timmermans"
date: "2024-11-13"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load data}
library(igraph)
```


```{r load data}
valid_edges <- read.csv("Valid_edges.csv")
data_combined <- read.csv("vertice_data.csv")

state_dependency_matrix <- readr::read_csv("state_dependency_matrix.csv")
state_dependency_matrix <- as.matrix(state_dependency_matrix)
rownames(state_dependency_matrix) <- colnames(state_dependency_matrix)
```



```{r pressure, echo=FALSE}
rivalry_edges <- subset(valid_edges, type == "rivalry")
g <- igraph::graph_from_data_frame(d = rivalry_edges, vertices = data_combined, directed = FALSE)

# Identify and remove isolates (nodes with degree zero)
isolates <- igraph::V(g)[igraph::degree(g) == 0]  # Find nodes with no connections
g <- igraph::delete_vertices(g, isolates)  # Remove isolates

# Change to network
g <- snafun::to_network(g)

# Filter only alliance relationships
alliance_edges <- subset(valid_edges, type == "alliance")
g_alliances <- graph_from_data_frame(d = alliance_edges, vertices = data_combined, directed = FALSE)
g_alliances <- snafun::to_network(g_alliances)
```



```{r}
m0 <- ergm::ergm(g ~ edges)
summary(m0)

```
```{r}
g_alliances_matrix <- as.matrix(g_alliances)
(dim(g_alliances_matrix))  # Ensure this matches the dimension of g
(any(is.na(g_alliances_matrix)))

g_rivalry_matrix <- as.matrix(g)
(dim(g_rivalry_matrix))  # Ensure this matches the dimension of g
(any(is.na(g_rivalry_matrix)))

# Step 1: Identify the common rows and columns
common_rows <- intersect(rownames(g_alliances_matrix), rownames(g_rivalry_matrix))
common_cols <- intersect(colnames(g_alliances_matrix), colnames(g_rivalry_matrix))

# Step 2: Subset both matrices to keep only the common rows and columns
g_alliances_matrix <- g_alliances_matrix[common_rows, common_cols, drop = FALSE]
(dim(g_alliances_matrix))  # Ensure this matches the dimension of g
(any(is.na(g_alliances_matrix)))

state_dependency_matrix <- as.matrix(state_dependency_matrix)

common_rows <- intersect(rownames(state_dependency_matrix), rownames(g_rivalry_matrix))
common_cols <- intersect(colnames(state_dependency_matrix), colnames(g_rivalry_matrix))

state_dependency_matrix1 <- state_dependency_matrix[common_rows, common_cols, drop = FALSE]
(dim(state_dependency_matrix1))  # Ensure this matches the dimension of g
(any(is.na(state_dependency_matrix1)))
```

```{r}
# Check node names in alliance network
alliance_node_names <- network::get.vertex.attribute(g_alliances, "vertex.names")
print(alliance_node_names)

# Check node names in rivalry network
rivalry_node_names <- network::get.vertex.attribute(g, "vertex.names")
print(rivalry_node_names)

# Standardize node names to lowercase and trim any whitespace
alliance_node_names <- tolower(trimws(alliance_node_names))
rivalry_node_names <- tolower(trimws(rivalry_node_names))

# Calculate degrees in alliance network
alliance_degrees <- sna::degree(alliance_net)

# Match alliance degrees to node names in rivalry network
alliance_degrees_matched <- alliance_degrees[match(rivalry_node_names, alliance_node_names)]

# Replace any NAs with 0 to ensure complete data
alliance_degrees_matched[is.na(alliance_degrees_matched)] <- 0

# Assign the matched alliance degree to rivalry network
set.vertex.attribute(g, "alliance_degree", alliance_degrees_matched)

```

```{r}

```

```{r}
# Retrieve the alliance_degree attribute
alliance_degree <- get.vertex.attribute(g, "alliance_degree")
# Find indices of nodes with NA in alliance_degree
na_indices <- which(is.na(alliance_degree))

# Print the names or indices of nodes with NA values
node_names_with_na <- get.vertex.attribute(rivalry_graph, "vertex.names")[na_indices]
node_names_with_na

```

```{r, fig.width=8, fig.height=6}
m1 <-ergm::ergm((g ~ edges + gwesp(0.5, fixed = TRUE) + edgecov(state_dependency_matrix1) + + nodecov("alliance_degree")), control = ergm::control.ergm(MCMC.burnin = 5000,
                                               MCMC.samplesize = 10000,
                                               seed = 123456,
                                               MCMLE.maxit = 20))
summary(m1)
ergm::mcmc.diagnostics(m1)

gofm <- ergm::gof(m1)
snafun::stat_plot_gof(gofm)

```

```{r, fig.width=8, fig.height=6}
m2 <-ergm::ergm((g ~ edges + gwesp(0.5, fixed = TRUE) + degree(1) + gwdsp(0.5, fixed = TRUE) + edgecov(state_dependency_matrix1)), control = ergm::control.ergm(MCMC.burnin = 5000,
                                               MCMC.samplesize = 10000,
                                               seed = 123456,
                                               MCMLE.maxit = 20))
summary(m2)
ergm::mcmc.diagnostics(m2)

gofm <- ergm::gof(m2)
snafun::stat_plot_gof(gofm)

```



```{r}
# Define the model formula (use a simpler model if complex terms are causing issues)
model_formula <- g ~ edges + degree(1)

# Fit the BTERGM model
btergm_model <- btergm::btergm(model_formula, R = 1000)

# Run GOF with explicit settings for `target` and increased `nsim`
fit_gof <- btergm::gof(
  btergm_model,
  nsim = 200,  # Increase to see if it resolves the issue
  target = network_list,
  statistics = c("degree", "esp", "distance", "triad")
)

# Plot the GOF results
plot(fit_gof)





```




